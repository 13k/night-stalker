// Code generated by modelgen. DO NOT EDIT.

package models

var _ Record = (*LiveMatchStats)(nil)

var LiveMatchStatsModel Model = (*modelLiveMatchStats)(nil)

// uses an anonymous struct to have compile-time checks when using associations
var assocLiveMatchStats = struct {
	LiveMatch Association
	Match     Association
	League    Association
	Teams     Association
	Players   Association
	Draft     Association
	Buildings Association
}{
	LiveMatch: NewAssociation(
		BelongsTo,
		&ModelAssociation{Model: LiveMatchStatsModel, Name: "LiveMatch", PK: "id", FK: "live_match_id"},
		&ModelAssociation{Model: LiveMatchModel, Name: "LiveMatchStats", PK: "id", FK: ""},
	),
	Match: NewAssociation(
		BelongsTo,
		&ModelAssociation{Model: LiveMatchStatsModel, Name: "Match", PK: "id", FK: "match_id"},
		&ModelAssociation{Model: MatchModel, Name: "LiveMatchStats", PK: "id", FK: ""},
	),
	League: NewAssociation(
		BelongsTo,
		&ModelAssociation{Model: LiveMatchStatsModel, Name: "League", PK: "id", FK: "league_id"},
		&ModelAssociation{Model: LeagueModel, Name: "LiveMatchStats", PK: "id", FK: ""},
	),
	Teams: NewAssociation(
		HasMany,
		&ModelAssociation{Model: LiveMatchStatsModel, Name: "Teams", PK: "id", FK: ""},
		&ModelAssociation{Model: LiveMatchStatsTeamModel, Name: "LiveMatchStats", PK: "id", FK: "live_match_stats_id"},
	),
	Players: NewAssociation(
		HasMany,
		&ModelAssociation{Model: LiveMatchStatsModel, Name: "Players", PK: "id", FK: ""},
		&ModelAssociation{Model: LiveMatchStatsPlayerModel, Name: "LiveMatchStats", PK: "id", FK: "live_match_stats_id"},
	),
	Draft: NewAssociation(
		HasMany,
		&ModelAssociation{Model: LiveMatchStatsModel, Name: "Draft", PK: "id", FK: ""},
		&ModelAssociation{Model: LiveMatchStatsPickBanModel, Name: "LiveMatchStats", PK: "id", FK: "live_match_stats_id"},
	),
	Buildings: NewAssociation(
		HasMany,
		&ModelAssociation{Model: LiveMatchStatsModel, Name: "Buildings", PK: "id", FK: ""},
		&ModelAssociation{Model: LiveMatchStatsBuildingModel, Name: "LiveMatchStats", PK: "id", FK: "live_match_stats_id"},
	),
}

type modelLiveMatchStats struct{}

func (*modelLiveMatchStats) Name() string             { return "LiveMatchStats" }
func (*modelLiveMatchStats) Table() Table             { return LiveMatchStatsTable }
func (*modelLiveMatchStats) NewRecord() Record        { return &LiveMatchStats{} }
func (*modelLiveMatchStats) NewSlicePtr() interface{} { return &[]*LiveMatchStats{} }

func (*modelLiveMatchStats) AsRecordSlice(v interface{}) ([]Record, error) {
	sptr, ok := v.(*[]*LiveMatchStats)

	if !ok {
		return nil, &ErrInvalidSliceType{Model: LiveMatchStatsModel, Value: v}
	}

	if sptr == nil || *sptr == nil {
		return nil, nil
	}

	rs := make([]Record, len(*sptr))

	for i, r := range *sptr {
		rs[i] = r
	}

	return rs, nil
}

func (*modelLiveMatchStats) Associations() []Association {
	return []Association{
		assocLiveMatchStats.LiveMatch,
		assocLiveMatchStats.Match,
		assocLiveMatchStats.League,
		assocLiveMatchStats.Teams,
		assocLiveMatchStats.Players,
		assocLiveMatchStats.Draft,
		assocLiveMatchStats.Buildings,
	}
}

func (*modelLiveMatchStats) Association(name string) (Association, error) {
	switch name {
	case "LiveMatch":
		return assocLiveMatchStats.LiveMatch, nil
	case "Match":
		return assocLiveMatchStats.Match, nil
	case "League":
		return assocLiveMatchStats.League, nil
	case "Teams":
		return assocLiveMatchStats.Teams, nil
	case "Players":
		return assocLiveMatchStats.Players, nil
	case "Draft":
		return assocLiveMatchStats.Draft, nil
	case "Buildings":
		return assocLiveMatchStats.Buildings, nil
	}

	return nil, &ErrNotAssociated{Model: LiveMatchStatsModel, Assoc: name}
}

func (*LiveMatchStats) Model() Model {
	return LiveMatchStatsModel
}

func (m *LiveMatchStats) AssignRecord(record Record) (bool, error) {
	if other, ok := record.(*LiveMatchStats); ok {
		return m.Assign(other), nil
	}

	return false, &ErrInvalidRecord{Model: m.Model(), Record: record}
}

func (m *LiveMatchStats) AssignPartialRecord(record Record) (bool, error) {
	if other, ok := record.(*LiveMatchStats); ok {
		return m.AssignPartial(other), nil
	}

	return false, &ErrInvalidRecord{Model: LiveMatchStatsModel, Record: record}
}

func (m *LiveMatchStats) GetAssocPK(assoc string) (ID, error) {
	switch assoc {
	case "Teams":
		return m.ID, nil
	case "Players":
		return m.ID, nil
	case "Draft":
		return m.ID, nil
	case "Buildings":
		return m.ID, nil
	}

	return m.ID, nil
}

func (m *LiveMatchStats) GetAssocFK(assoc string) (ID, error) {
	switch assoc {
	case "LiveMatch":
		return m.LiveMatchID, nil
	case "Match":
		return m.MatchID, nil
	case "League":
		return m.LeagueID, nil
	}

	return 0, &ErrNotAssociated{Model: LiveMatchStatsModel, Assoc: assoc}
}

func (m *LiveMatchStats) SetAssociated(assoc string, records ...Record) error {
	if len(records) == 0 {
		return nil
	}

	switch assoc {
	case "LiveMatch":
		r := records[0]

		if mr, ok := r.(*LiveMatch); ok {
			m.LiveMatch = mr
			return nil
		}

		return &ErrInvalidAssociationRecord{Assoc: assocLiveMatchStats.LiveMatch, Record: r}
	case "Match":
		r := records[0]

		if mr, ok := r.(*Match); ok {
			m.Match = mr
			return nil
		}

		return &ErrInvalidAssociationRecord{Assoc: assocLiveMatchStats.Match, Record: r}
	case "League":
		r := records[0]

		if mr, ok := r.(*League); ok {
			m.League = mr
			return nil
		}

		return &ErrInvalidAssociationRecord{Assoc: assocLiveMatchStats.League, Record: r}
	case "Teams":
		mrs := make([]*LiveMatchStatsTeam, len(records))

		for i, r := range records {
			mr, ok := r.(*LiveMatchStatsTeam)

			if !ok {
				return &ErrInvalidAssociationRecord{Assoc: assocLiveMatchStats.Teams, Record: r}
			}

			mrs[i] = mr
		}

		m.Teams = mrs
		return nil
	case "Players":
		mrs := make([]*LiveMatchStatsPlayer, len(records))

		for i, r := range records {
			mr, ok := r.(*LiveMatchStatsPlayer)

			if !ok {
				return &ErrInvalidAssociationRecord{Assoc: assocLiveMatchStats.Players, Record: r}
			}

			mrs[i] = mr
		}

		m.Players = mrs
		return nil
	case "Draft":
		mrs := make([]*LiveMatchStatsPickBan, len(records))

		for i, r := range records {
			mr, ok := r.(*LiveMatchStatsPickBan)

			if !ok {
				return &ErrInvalidAssociationRecord{Assoc: assocLiveMatchStats.Draft, Record: r}
			}

			mrs[i] = mr
		}

		m.Draft = mrs
		return nil
	case "Buildings":
		mrs := make([]*LiveMatchStatsBuilding, len(records))

		for i, r := range records {
			mr, ok := r.(*LiveMatchStatsBuilding)

			if !ok {
				return &ErrInvalidAssociationRecord{Assoc: assocLiveMatchStats.Buildings, Record: r}
			}

			mrs[i] = mr
		}

		m.Buildings = mrs
		return nil
	}

	return &ErrNotAssociated{Model: LiveMatchStatsModel, Assoc: assoc}
}

// Code generated by modelgen. DO NOT EDIT.

package models

var _ Record = (*LiveMatchStatsTeam)(nil)

var LiveMatchStatsTeamModel Model = (*modelLiveMatchStatsTeam)(nil)

// uses an anonymous struct to have compile-time checks when using associations
var assocLiveMatchStatsTeam = struct {
	LiveMatchStats Association
	Team           Association
}{
	LiveMatchStats: NewAssociation(
		BelongsTo,
		&ModelAssociation{Model: LiveMatchStatsTeamModel, Name: "LiveMatchStats", PK: "id", FK: "live_match_stats_id"},
		&ModelAssociation{Model: LiveMatchStatsModel, Name: "LiveMatchStatsTeam", PK: "id", FK: ""},
	),
	Team: NewAssociation(
		BelongsTo,
		&ModelAssociation{Model: LiveMatchStatsTeamModel, Name: "Team", PK: "id", FK: "team_id"},
		&ModelAssociation{Model: TeamModel, Name: "LiveMatchStatsTeam", PK: "id", FK: ""},
	),
}

type modelLiveMatchStatsTeam struct{}

func (*modelLiveMatchStatsTeam) Name() string             { return "LiveMatchStatsTeam" }
func (*modelLiveMatchStatsTeam) Table() Table             { return LiveMatchStatsTeamTable }
func (*modelLiveMatchStatsTeam) NewRecord() Record        { return &LiveMatchStatsTeam{} }
func (*modelLiveMatchStatsTeam) NewSlicePtr() interface{} { return &[]*LiveMatchStatsTeam{} }

func (*modelLiveMatchStatsTeam) AsRecordSlice(v interface{}) ([]Record, error) {
	sptr, ok := v.(*[]*LiveMatchStatsTeam)

	if !ok {
		return nil, &ErrInvalidSliceType{Model: LiveMatchStatsTeamModel, Value: v}
	}

	if sptr == nil || *sptr == nil {
		return nil, nil
	}

	rs := make([]Record, len(*sptr))

	for i, r := range *sptr {
		rs[i] = r
	}

	return rs, nil
}

func (*modelLiveMatchStatsTeam) Associations() []Association {
	return []Association{
		assocLiveMatchStatsTeam.LiveMatchStats,
		assocLiveMatchStatsTeam.Team,
	}
}

func (*modelLiveMatchStatsTeam) Association(name string) (Association, error) {
	switch name {
	case "LiveMatchStats":
		return assocLiveMatchStatsTeam.LiveMatchStats, nil
	case "Team":
		return assocLiveMatchStatsTeam.Team, nil
	}

	return nil, &ErrNotAssociated{Model: LiveMatchStatsTeamModel, Assoc: name}
}

func (*LiveMatchStatsTeam) Model() Model {
	return LiveMatchStatsTeamModel
}

func (m *LiveMatchStatsTeam) AssignRecord(record Record) (bool, error) {
	if other, ok := record.(*LiveMatchStatsTeam); ok {
		return m.Assign(other), nil
	}

	return false, &ErrInvalidRecord{Model: m.Model(), Record: record}
}

func (m *LiveMatchStatsTeam) AssignPartialRecord(record Record) (bool, error) {
	if other, ok := record.(*LiveMatchStatsTeam); ok {
		return m.AssignPartial(other), nil
	}

	return false, &ErrInvalidRecord{Model: LiveMatchStatsTeamModel, Record: record}
}

func (m *LiveMatchStatsTeam) GetAssocPK(assoc string) (ID, error) {
	return m.ID, nil
}

func (m *LiveMatchStatsTeam) GetAssocFK(assoc string) (ID, error) {
	switch assoc {
	case "LiveMatchStats":
		return m.LiveMatchStatsID, nil
	case "Team":
		return m.TeamID, nil
	}

	return 0, &ErrNotAssociated{Model: LiveMatchStatsTeamModel, Assoc: assoc}
}

func (m *LiveMatchStatsTeam) SetAssociated(assoc string, records ...Record) error {
	if len(records) == 0 {
		return nil
	}

	switch assoc {
	case "LiveMatchStats":
		r := records[0]

		if mr, ok := r.(*LiveMatchStats); ok {
			m.LiveMatchStats = mr
			return nil
		}

		return &ErrInvalidAssociationRecord{Assoc: assocLiveMatchStatsTeam.LiveMatchStats, Record: r}
	case "Team":
		r := records[0]

		if mr, ok := r.(*Team); ok {
			m.Team = mr
			return nil
		}

		return &ErrInvalidAssociationRecord{Assoc: assocLiveMatchStatsTeam.Team, Record: r}
	}

	return &ErrNotAssociated{Model: LiveMatchStatsTeamModel, Assoc: assoc}
}

package cmdapi

import (
	"fmt"
	"io"

	"github.com/13k/night-stalker/cmd/modelgen/internal/common"
	mg "github.com/13k/night-stalker/cmd/modelgen/internal/parser"
)

const (
	//nolint: lll
	srcAPI = `
{{- $varModel := varModel .Model -}}
{{- $varModelAssociations := .Model_Var_Associations -}}
{{- $ifaceAssociation := .InterfaceAssociation -}}
{{- $structModelAssociation := .StructModelAssociation -}}
{{- $errInvalidAssociationRecord := .ErrInvalidAssociationRecord -}}
// Code generated by modelgen. DO NOT EDIT.

package {{.Package}}

var _ {{.InterfaceRecord}} = (*{{.Model}})(nil)

var {{$varModel}} {{.InterfaceModel}} = (*{{.Model_Struct}})(nil)

{{ if .Associations }}
// uses an anonymous struct to have compile-time checks when using associations
var {{$varModelAssociations}} = struct{
	{{ range .Associations -}}
	{{.SrcName}} {{$ifaceAssociation}}
	{{ end -}}
}{
	{{ range .Associations -}}
	{{.SrcName}}: NewAssociation(
		{{.Type}},
		&{{$structModelAssociation}}{Model: {{varModel .SrcModel}}, Name: "{{.SrcName}}", PK: "{{.SrcPKCol}}", FK: "{{.SrcFKCol}}"},
		&{{$structModelAssociation}}{Model: {{varModel .DestModel}}, Name: "{{.DestName}}", PK: "{{.DestPKCol}}", FK: "{{.DestFKCol}}"},
	),
	{{ end -}}
}
{{ end }}

type {{.Model_Struct}} struct{}

func (*{{.Model_Struct}}) {{.Model_Method_Name}}() string { return "{{.Model}}" }
func (*{{.Model_Struct}}) {{.Model_Method_Table}}() {{.InterfaceTable}} { return {{.Table_Var}} }
func (*{{.Model_Struct}}) {{.Model_Method_RecordFactory}}() {{.InterfaceRecord}} { return &{{.Model}}{} }
func (*{{.Model_Struct}}) {{.Model_Method_SlicePtrFactory}}() interface{}  { return &[]*{{.Model}}{} }

func (*{{.Model_Struct}}) {{.Model_Method_RecordSliceCaster}}(v interface{}) ([]{{.InterfaceRecord}}, error) {
	sptr, ok := v.(*[]*{{.Model}})

	if !ok {
		return nil, &{{.ErrInvalidSliceType}}{Model: {{$varModel}}, Value: v}
	}

	if sptr == nil || *sptr == nil {
		return nil, nil
	}

	rs := make([]{{.InterfaceRecord}}, len(*sptr))

	for i, r := range *sptr {
		rs[i] = r
	}

	return rs, nil
}

func (*{{.Model_Struct}}) {{.Model_Method_Associations}}() []{{$ifaceAssociation}} {
	{{- if .Associations -}}
	return []Association{
		{{ range .Associations -}}
		{{$varModelAssociations}}.{{.SrcName}},
		{{ end -}}
	}
	{{ else -}}
	return nil
	{{ end -}}
}

func (*{{.Model_Struct}}) {{.Model_Method_Association}}(name string) ({{$ifaceAssociation}}, error) {
	{{- if .Associations -}}
	switch name {
		{{- range .Associations -}}
	case "{{.SrcName}}":
		return {{$varModelAssociations}}.{{.SrcName}}, nil
		{{ end -}}
	}

	{{ end -}}
	return nil, &{{.ErrNotAssociated}}{Model: {{$varModel}}, Assoc: name}
}

func (*{{.Model}}) {{.Record_Method_Model}}() Model {
	return {{$varModel}}
}

{{ $recv := .Record_Recv -}}

func ({{$recv}} *{{.Model}}) {{.Record_Method_AssignRecord}}(record {{.InterfaceRecord}}) (bool, error) {
	if other, ok := record.(*{{.Model}}); ok {
		return {{$recv}}.{{.Record_Method_Assign}}(other), nil
	}

	return false, &{{.ErrInvalidRecord}}{Model: {{$recv}}.{{.Record_Method_Model}}(), Record: record}
}

func ({{$recv}} *{{.Model}}) {{.Record_Method_AssignPartialRecord}}(record {{.InterfaceRecord}}) (bool, error) {
	if other, ok := record.(*{{.Model}}); ok {
		return {{$recv}}.{{.Record_Method_AssignPartial}}(other), nil
	}

	return false, &{{.ErrInvalidRecord}}{Model: {{$varModel}}, Record: record}
}

func ({{$recv}} *{{.Model}}) {{.Record_Method_GetPK}}(assoc string) ({{.TypeID}}, error) {
	{{- if (or .Associations_HasOne .Associations_HasMany) -}}
	switch assoc {
		{{- range .Associations_HasOne -}}
	case "{{.SrcName}}":
		return {{$recv}}.{{.SrcPKField}}, nil
		{{ end -}}
		{{- range .Associations_HasMany -}}
	case "{{.SrcName}}":
		return {{$recv}}.{{.SrcPKField}}, nil
		{{ end -}}
	}

	{{ end -}}
	return {{$recv}}.ID, nil
}

func ({{$recv}} *{{.Model}}) {{.Record_Method_GetFK}}(assoc string) ({{.TypeID}}, error) {
	{{- if .Associations_BelongsTo -}}
	switch assoc {
		{{- range .Associations_BelongsTo -}}
	case "{{.SrcName}}":
		return {{$recv}}.{{.SrcFKField}}, nil
		{{ end -}}
	}

	{{ end -}}
	return 0, &{{.ErrNotAssociated}}{Model: {{$varModel}}, Assoc: assoc}
}

func ({{$recv}} *{{.Model}}) {{.Record_Method_SetAssociated}}(assoc string, records ...{{.InterfaceRecord}}) error {
	{{- if .Associations -}}
	if len(records) == 0 {
		return nil
	}

	switch assoc {
		{{- range .Associations -}}
			{{- if .IsOneToOne -}}
	case "{{.SrcName}}":
		r := records[0]

		if mr, ok := r.(*{{.DestModel}}); ok {
			{{$recv}}.{{.SrcName}} = mr
			return nil
		}

		return &{{$errInvalidAssociationRecord}}{Assoc: {{$varModelAssociations}}.{{.SrcName}}, Record: r}
			{{ else if .IsOneToMany -}}
	case "{{.SrcName}}":
		mrs := make([]*{{.DestModel}}, len(records))

		for i, r := range records {
			mr, ok := r.(*{{.DestModel}})

			if !ok {
				return &{{$errInvalidAssociationRecord}}{Assoc: {{$varModelAssociations}}.{{.SrcName}}, Record: r}
			}

			mrs[i] = mr
		}

		{{$recv}}.{{.SrcName}} = mrs
		return nil
			{{ end -}}
		{{ end -}}
	}

	{{ end -}}

	return &{{.ErrNotAssociated}}{Model: {{$varModel}}, Assoc: assoc}
}
`
)

var (
	tplFuncMap = map[string]interface{}{
		"varModel": varModel,
	}

	tplAPI = common.CreateTemplate("api", srcAPI, tplFuncMap)
)

func tplValues(
	p *mg.Package,
	s *mg.Struct,
	recv string,
	assocs []*association,
) map[string]interface{} {
	pkgName := p.Name
	modelName := s.Name

	var assocsBelongsTo, assocsHasOne, assocsHasMany []*association

	for _, assoc := range assocs {
		switch assoc.Type {
		case "BelongsTo":
			assocsBelongsTo = append(assocsBelongsTo, assoc)
		case "HasOne":
			assocsHasOne = append(assocsHasOne, assoc)
		case "HasMany":
			assocsHasMany = append(assocsHasMany, assoc)
		default:
			panic(fmt.Sprintf("invalid relationship type %q\n", assoc.Type))
		}
	}

	return map[string]interface{}{
		"Package":                           pkgName,
		"TypeID":                            common.TypeID,
		"Model":                             modelName,
		"InterfaceModel":                    common.InterfaceModel,
		"InterfaceRecord":                   common.InterfaceRecord,
		"InterfaceTable":                    common.InterfaceTable,
		"InterfaceAssociation":              common.InterfaceAssociation,
		"StructModelAssociation":            common.StructModelAssociation,
		"Table_Var":                         fmt.Sprintf(common.FmtTableVar, modelName),
		"Model_Var_Associations":            fmt.Sprintf(common.FmtModelVarAssociations, modelName),
		"Model_Struct":                      fmt.Sprintf(common.FmtModelStruct, modelName),
		"Model_Method_Name":                 common.ModelMethodName,
		"Model_Method_Table":                common.ModelMethodTable,
		"Model_Method_RecordFactory":        common.ModelMethodRecordFactory,
		"Model_Method_SlicePtrFactory":      common.ModelMethodSlicePtrFactory,
		"Model_Method_RecordSliceCaster":    common.ModelMethodRecordSliceCaster,
		"Model_Method_Associations":         common.ModelMethodAssociations,
		"Model_Method_Association":          common.ModelMethodAssociation,
		"Record_Recv":                       recv,
		"Record_Method_Model":               common.RecordMethodModel,
		"Record_Method_AssignRecord":        common.RecordMethodAssignRecord,
		"Record_Method_AssignPartialRecord": common.RecordMethodAssignPartialRecord,
		"Record_Method_Assign":              common.RecordMethodAssign,
		"Record_Method_AssignPartial":       common.RecordMethodAssignPartial,
		"Record_Method_GetPK":               common.RecordMethodGetAssocPK,
		"Record_Method_GetFK":               common.RecordMethodGetAssocFK,
		"Record_Method_SetAssociated":       common.RecordMethodSetAssociated,
		"ErrInvalidSliceType":               common.ErrInvalidSliceType,
		"ErrNotAssociated":                  common.ErrNotAssociated,
		"ErrInvalidRecord":                  common.ErrInvalidRecord,
		"ErrInvalidAssociationRecord":       common.ErrInvalidAssociationRecord,
		"Associations":                      assocs,
		"Associations_BelongsTo":            assocsBelongsTo,
		"Associations_HasOne":               assocsHasOne,
		"Associations_HasMany":              assocsHasMany,
	}
}

func execTplAPI(
	w io.Writer,
	p *mg.Package,
	s *mg.Struct,
	recv string,
	rels []*association,
) error {
	return common.ExecTemplate(w, tplAPI, tplValues(p, s, recv, rels))
}

func varModel(modelName string) string {
	return fmt.Sprintf(common.FmtModelVar, modelName)
}
